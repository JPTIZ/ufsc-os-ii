\documentclass{report}

\input{preamble}

\newcommand{\todo}[1]{{\color{red} #1}}

\title{\todo{A gente descobre depois}}

\author{João Gabriel Trombeta\\
        João Paulo Taylor Ienczak Zanette\\
        Ranieri Schroeder Althoff}
\date{\today}

\begin{document}

\maketitle

\tableofcontents

\chapter{Máquinas Virtuais}

\section{Sobre Máquinas Virtuais}

De maneira sucinta, máquinas virtuais (VM --- \textit{Virtual Machines}) são
computadores sendo executados por outros computadores. Chama-se de
\textbf{Guest} a máquina virtual em si, e de \textbf{Host} o \textit{hardware}
que oferece recursos para executar a VM\@. No host, uma camada de software
chamada hypervisor permite a execução de múltiplas máquinas virtuais
independente sem uma única máquina física, cada uma executando seu próprio
SO\@.

\section{Hypervisor}

Também chamado de Monitor de Máquina Virtual (VMM --- \textit{Virtual Machine
Monitor}), um \textbf{Hypervisor} é um componente (seja \textit{hardware},
\textit{software} ou \textit{firmware}) responsável por criar e executar uma
VM, sendo o \textit{Host} o computador em que o Hypervisor é executado.

O Hypervisor é responsável pela camada de abstração entre o host e os guests,
realizando o gerenciamento de recursos, uma vez que cada guest trabalha na
ilusão de que todos os recursos de hardware são seus. Cada VM deve ser isolada
para evitar que uma VM possa comprometer o funcionamento de outra, por isso
toda interação com o meio físico é intermediada pelo Hypervisor, que é
fortemente protegido das VM\@.

\section{Falhas em Hypervisors}

\subsection{Xen Hypervisor}

Uma falha de segurança detectada com relação a Hypervisors foi explorada no Xen
Hypervisor (criado pelo Xen Project, composto por membros da The Linux
Foundation), em que é possível chamar uma função arbitrária alterando a tabela
de \textit{Hypercalls} (semelhante a uma \textit{vtable}). Uma
\textit{Hypercall} é \textit{software trap} do Hypervisor para executar
operações privilegiadas (como atualizar tabelas de página).

Para explorar a falha, primeiramente é necessário descobrir a localização da
tabela de \textit{Hypercalls}. Para isso, deve-se procurar pela assinatura da
página (dada pelo \textit{checksum} de seu conteúdo). Porém, como essa página
não possui um conteúdo tão previsível, é difícil de localizá-la. Em
compensação, a tabela de argumentos dos \textit{Hypercalls} possui um formato
previsível, já que seu conteúdo --- que é o número de argumentos de cada
\textit{Hypercall} --- é fixo, e portanto seu \textit{checksum} também é
previsível. Além disso, a tabela de argumentos sempre se encontra na página
seguinte à tabela de \textit{Hypercalls}, e portanto, ao encontrar uma, se tem
a localização da outra. Aliado à possibilidade de leitura e escrita de código
arbitrário, feito através de falhas nas regras de verificação de segurança de
escrita em páginas do \textit{Hypervision}, é possível então efetuar escape de
máquina virtual (i.e.\ acessar recursos do \textit{Host} que não pertencem à
máquina virtual).

\chapter{AMD Memory Encryption}

\section{AMD Secure Processor}

Grande parte das funções de criptografia executadas em um AMD utilizam um
processador dedicado e independente, o AMD Secure Processor (AMD-SP,
antigamente chamado de Platform Security Processor), que garante que
componentes sensíveis à segurança não recebam interferência do software dos
processadores principais.

O AMD-SP roda um kernel seguro de código fechado, que pode executar tarefas do
sistema assim como tarefas de terceiros confiáveis, tendo o administrador
controle sobre quais tarefas de terceiros são designadas ao processador. Além
disso, o Secure Processor possui uma SRAM dedicada e acesso direto ao CCP, que
é composto por um gerador de números aleatórios, várias engines para o
processamento de algoritmos de criptografia, e um bloco para o armazenamento de
chaves.

\section{Security Memory Encryption}
O AMD Secure Memory Encryption (SME) é um mecanismo que pode ser utilizado para
criptografar os dados que vão para a DRAM, com a finalidade de evitar ataques
físicos. Durante o boot, o AMD Secure Processor gera uma chave que será usada
para criptografar e descriptografar os dados que transitam pela DRAM\@. Como o
a engine de criptografia está dentro do chip o impacto das operações é pequeno.

\begin{figure}[h]
    \centering
    \includegraphics[width=0.5\textwidth]{img/sme}
    \caption{Método de criptografia do SME}\label{sme-1}
\end{figure}

A figura~\ref{sme-1} mostra como ocorre a criptografia. A engine é posicionada
entre o OS/Hypervisor, onde dada a chave o dado é criptografado antes de ser
salvo na DRAM\@. Ao passar da DRAM para o SO novamente, os dados são
descriptografados.

Esse tipo de segurança não previne ataques advindos de um Hypervisor
comprometido, uma vez que ele possui acesso aos dados de maneira direta, esse
tipo de segurança tem com o objetivo evitar ataques como \todo{probe attack na
DRAM}, instalação de hardware que possa acessar a memória do guest, ataques que
possam capturar dados de DIMM e NVDIMM\@.

Para utilizar SME, é necessário verificar se o processador possui suporte para
esse recurso, o que pode ser verificado através da chamada de CPUID
Fn8000\_001F, e que durante o boot o bit 23 de SYSCFG MSR esteja definido como
1 para sinalizar que esse recurso está habilitado. Após isso, ao fazer acesso à
DRAM, é visto o último bit mais significativo do endereço, chamado de C-bit,
que define se o dado deve ou não ser criptografado.

\begin{figure}[h]
    \centering
    \includegraphics[width=0.5\textwidth]{img/sme_read_write_architecture}
    \caption{Leitura e escrita no SME}\label{sme-read-write}
\end{figure}

Como visto em~\ref{sme-read-write}, para a leitura, antes do dado passar para
CPU, duas versões do dado são inseridas como entrada de um mux, um com o dado
como estava na DRAM e outra com o dado após passar pelo circuito responsável
pela criptografia. O controle do mux recebe o bit mais significativo do
endereço, o C-bit, caso seja 1 significa que o dado está criptografado e a CPU
precisa da informação descriptografada, caso seja 0 significa que o dado pode
ser passado direto para a CPU\@.

Para a escrita a lógica é a mesma, caso o C-bit seja 1 o dado deve ser
criptogrado antes de ser inserido na DRAM, caso seja 0 o dado pode ser salvo
diretamente.

Ainda existe uma variação chamada Transparent SME, onde tudo é criptografado.
Nesse caso não é necessário suporte do SO, tendo em vista que não é preciso
fazer o controle de quais endereços serã criptografados e quais não. O processo
de acesso à memória ocorre da mesma forma que em SME\@.


\section{Secure Encrypted Virtualization}

\section{Utilização do SME e SEV}

\subsection{\textit{Set-up} e comunicação}

\begin{table}[h]
    \centering
    \begin{tabular}{lll}
        \toprule
        Status  & Código\\
        \midrule
        SUCCESS & 0000h\\
        INVALID\_PLATFORM\_STATE & 0001h\\
        INVALID\_GUEST\_STATE & 0002h\\
        INVALID\_CONFIG & 0003h\\
        INVALID\_LENGTH & 0004h\\
        ALREADY\_OWNED & 0005h\\
        INVALID\_CERTIFICATE & 0006h\\
        POLICY\_FAILURE & 0007h\\
        INACTIVE & 0008h\\
        INVALID\_ADDRESS & 0009h\\
        BAD\_SIGNATURE & 000Ah\\
        BAD\_MEASUREMENT & 000Bh\\
        ASID\_OWNED & 000Ch\\
        INVALID\_ASID & 000Dh\\
        WBINVD\_REQUIRED & 000Eh\\
        DFFLUSH\_REQUIRED & 0009h\\
        INVALID\_GUEST & 0010h\\
        INVALID\_COMMAND & 0011h\\
        ACTIVE & 0012h\\
        HWERROR\_PLATFORM & 0013h\\
        HWERROR\_UNSAFE & 0014h\\
        UNSUPPORTED & 0015h\\
        INVALID\_PARAM & 0016h\\
        \bottomrule
    \end{tabular}
    \caption{Relação dos códigos de status dados pelo AMD-SP\@. Mais detalhes
             sobre a tabela estão
             em~\cite{sev-api-doc}}\label{cmdresp-status-code}
\end{table}

A comunicação entre o AMD-SP e o x86 se dá por meio de registradores MMIO
(\textit{Memory Mapped IO}), chamados de \textit{``mailbox registers''}. Um
\textit{mailbox} essencial \textit{``Command buffer''}, que será lido/escrito
pelo \textit{Driver} responsável pela implementação do SEV para enviar comandos
relacionados ao SEV para o \textit{firmware}. Primeiramente é necessário, além
de alterar o MSR, definir o endereço de memória em que ficará o \textit{Command
Buffer}, separado em dois registradores: \texttt{CmdBufAddr\_Hi} e
\texttt{CmdBufAddr\_Lo} (32 bits mais e menos significativos, respectivamente).
Internamente, o registrador do \textit{Command Buffer} é chamado de
\texttt{CmdResp}, e é utilizado da forma:

\begin{enumerate}
    \item O driver (em x86) altera o \texttt{CmdResp} com:
        \begin{itemize}
            \item Bit 31 em 0 (simbolizando a emissão de um comando);
            \item Bits 30 a 26 mantidos em 0 (pois são reservados);
            \item Bits 25 a 16 com o ID do comando a ser emitido;
            \item Bits 15 a 1 também são mantidos em 0 (por serem reservados);
            \item Bit 0 pode ser colocado em 1 para informar o
                \textit{firmware} para habilitar uma interrupção no x86 ao
                completar o comando, do contrário pode ser mantido em 0.
        \end{itemize}
    \item O AMD-SP executa o comando;
    \item Após completar o comando, o AMD-SP escreve no \texttt{CmdResp} com o
        resultado da execução do comando, da forma:
        \begin{itemize}
            \item Bit 31 em 1 para indicar que se trata de uma resposta;
            \item Bits 15 a 0 com o código de status descritos na
                tabela~\ref{cmdresp-status-code}.
        \end{itemize}
\end{enumerate}

\subsection{Comandos}

\subsubsection{INIT}

O comando \texttt{INIT}, intuitivamente, inicializa a plataforma. Isso é feito
carregando os dados de persistência relacionados ao SEV, vindos de algum
armazenamento não-volátil, e inicializando o contexto da plataforma.
Geralmente, os casos em que este não é o primeiro comando executado são os que
primeiramente utilizam comandos como \texttt{PLATFORM\_STATUS} para determinar
a versão da API\@. Requer que o estado da plataforma seja
\texttt{PSTATE.UNINIT};

\subsubsection{SHUTDOWN}

Utilizado pelo dono da plataforma afim de alterar o estado dela para
não-inicializado. A plataforma pode estar em qualquer estado e, quando
executado, todo o estado da plataforma e dos \textit{Guests} é excluído do
armazenamento volátil.

\subsubsection{PLATFORM\_RESET}

Reinicia os dados não-voláteis de SEV, sendo útil quando o dono deseja
transferir a plataforma para um novo dono ou apenas liberar os recursos do
sistema seguramente.

\subsubsection{PLATFORM\_STATUS}

Informa sobre o status atual da plataforma, incluindo versão da API
(\textit{major} e \textit{minor}), dono (se é o próprio \textit{Host} ou é
externo), ID da \textit{build} do \textit{firmware}, número de \textit{Guests}
válidos mantidos pelo \textit{firmware}, e código de status do
\textit{firmware}.

\subsubsections{Outros comandos}

Há outros comandos relativos às chaves, como \texttt{PEK\_GEN},
\texttt{PEK\_CSR}, \texttt{PEK\_CERT\_IMPORT}, \texttt{PDH\_GEN} e
\texttt{PDH\_CERT\_EXPORT}, que permitem gerar, trocar e validar chaves.

\bibliographystyle{ieeetr}
\nocite{*}
\bibliography{references}

\end{document}
