\documentclass{report}

\input{preamble}

\newcommand{\todo}[1]{{\color{red} #1}}

\title{\todo{A gente descobre depois}}

\author{João Gabriel Trombeta\\
        João Paulo Taylor Ienczak Zanette\\
        Ranieri Schroeder Althoff}
\date{\today}

\begin{document}

\maketitle

\tableofcontents

\chapter{Máquinas Virtuais}

Máquinas virtuais (VM, na sigla em inglês para \textit{Virtual Machines}) são
emuladores de computadores lógicos, implementando arquiteturas e conjuntos de
instruções para prover a funcionalidade de um computador físico. Chama-se de
\textit{guest} ou convidado o computador executado pela máquina virtual, e de
\textit{host} ou hospedeiro o computador cujo \textit{hardware} oferece
recursos para executar a máquina virtual. No \textit{host}, uma camada de
software chamada hypervisor permite a execução máquinas virtuais em uma máquina
física, independentes entre si e executando sistemas operacionais semelhantes
ou não.

\section{Hypervisor}

Também chamado de monitor de máquina virtual (VMM, na sigla em inglês para
\textit{Virtual Machine Monitor}), um \textit{hypervisor} é um componente em
forma de \textit{hardware}, \textit{software} ou \textit{firmware}, responsável
por criar e executar uma máquina virtual. \textit{Hypervisors} podem ser do
tipo nativo (ou \textit{bare metal}), quando executa suas máquinas virtuais
diretamente no \textit{hardware} do \textit{host}, ou \textit{hosted}, quando
executa \textit{software} sobre o sistema operacional do \textit{host}, sendo
gerenciado pelo \textit{kernel} do mesmo.

O \textit{hypervisor} é responsável pela camada de abstração entre o
\textit{host} e os \textit{guests}, realizando o gerenciamento de recursos,
pois um \textit{guest} individualmente é isolado de forma que todos os recursos
de \textit{hardware} visíveis são considerados seus. Cada máquina virtual deve
ser gerenciada de forma a evitar que comprometa o funcionamento das outras, por
isso toda interação com o meio físico é intermediada pelo \textit{hypervisor},
que é fortemente protegido das máquinas virtuais por ele gerenciadas.

\section{Falhas em Hypervisors}

\subsection{Xen Hypervisor}

Uma falha de segurança detectada com relação a \textit{hypervisors} foi
explorada no \textbf{Xen Hypervisor}, um dos \textit{hypervisors} mais
populares da atualidade, em que é possível executar uma função arbitrária
alterando a tabela de \textit{hypercalls}, algo semelhante a uma
\textit{vtable} no contexto de \textit{hypervisors}. Uma \textit{hypercall} é
uma \textit{software trap} (uma interrupção) do \textit{hypervisor} para
executar operações privilegiadas, como atualizar tabelas de página das máquinas
virtuais.

Para explorar a falha, primeiramente é necessário descobrir a localização da
tabela de \textit{hypercalls} procurando pela assinatura da página. Como a
página não possui um formato tão previsível, é difícil de localizá-la, o que é
feito pelo \textit{checksum} do conteúdo da página, mas a tabela de argumentos
dos \textit{hypercalls} possui um formato previsível, já que seu conteúdo, que
é o número de argumentos de cada \textit{hypercall}, é fixo, portanto seu
\textit{checksum} também é previsível. Além disso, a tabela de argumentos
sempre se encontra na página seguinte à tabela de \textit{hypercalls}, o que
implica que basta encontrar uma das tabelas para que se tenha a localização da
outra.

Aliado à possibilidade de leitura e escrita de código arbitrário, feito através
de falhas nas regras de verificação de segurança de escrita em páginas do
\textit{hypervisor}, é possível então efetuar escape de máquina virtual, por
exemplo, acessando recursos do \textit{host} que não estão alocados para
máquina virtual.

\subsection{VMware ESXi e KVM}

\chapter{AMD Memory Encryption}

\section{AMD Secure Processor}

Grande parte das funções de criptografia executadas em um processador AMD
utilizam um processador dedicado e independente, o \textbf{AMD Secure
Processor} (AMD-SP, chamado anteriormente de \textbf{Platform Security
Processor}), que garante que componentes sensíveis à segurança não recebam
interferência do \textit{software} sendo executado nos processadores
principais.

O AMD-SP roda um \textit{kernel} seguro de código fechado, que pode executar
tarefas do sistema assim como tarefas de terceiros confiáveis, tendo o
administrador controle sobre quais tarefas de terceiros são designadas ao
processador. Além disso, possui uma memória dedicada e acesso direto ao
coprocessador criptográfico (CCP), que é composto por um gerador de números
aleatórios, várias engines para o processamento de algoritmos de criptografia,
e um bloco para o armazenamento de chaves.

\section{Security Memory Encryption}
O \textbf{AMD Secure Memory Encryption} (SME) é um mecanismo que pode ser
utilizado para criptografar os dados que são escritos na RAM, com a finalidade
de evitar ataques físicos. Durante o boot, o AMD-SP gera uma chave simétrica
que será usada para criptografar e descriptografar os dados que transitam pela
DRAM. Como a \textit{engine} de criptografia está dentro do chip, o impacto das
operações é pequeno.

\begin{figure}[h]
    \centering
    \includegraphics[width=0.5\textwidth]{img/sme}
    \caption{Método de criptografia do SME}\label{sme-1}
\end{figure}

A figura~\ref{sme-1} mostra como ocorre a criptografia. A engine é posicionada
entre o OS/Hypervisor, onde dada a chave o dado é criptografado antes de ser
salvo na DRAM\@. Ao passar da DRAM para o SO novamente, os dados são
descriptografados.

Esse tipo de segurança não previne ataques advindos de um Hypervisor
comprometido, uma vez que ele possui acesso aos dados de maneira direta, esse
tipo de segurança tem com o objetivo evitar ataques como \todo{probe attack na
DRAM}, instalação de hardware que possa acessar a memória do guest, ataques que
possam capturar dados de DIMM e NVDIMM\@.

Para utilizar SME, é necessário verificar se o processador possui suporte para
esse recurso, o que pode ser verificado através da chamada de CPUID
Fn8000\_001F, e que durante o boot o bit 23 de SYSCFG MSR esteja definido como
1 para sinalizar que esse recurso está habilitado. Após isso, ao fazer acesso à
DRAM, é visto o último bit mais significativo do endereço, chamado de C-bit,
que define se o dado deve ou não ser criptografado.

\begin{figure}[h]
    \centering
    \includegraphics[width=0.5\textwidth]{img/sme_read_write_architecture.png}
    \caption{Leitura e escrita no SME}\label{sme-read-write}
\end{figure}

Como visto em~\ref{sme-read-write}, para a leitura, antes do dado passar para
CPU, duas versões do dado são inseridas como entrada de um mux, um com o dado
como estava na DRAM e outra com o dado após passar pelo circuito responsável
pela criptografia. O controle do mux recebe o bit mais significativo do
endereço, o C-bit, caso seja 1 significa que o dado está criptografado e a CPU
precisa da informação descriptografada, caso seja 0 significa que o dado pode
ser passado direto para a CPU\@.

Para a escrita a lógica é a mesma, caso o C-bit seja 1 o dado deve ser
criptogrado antes de ser inserido na DRAM, caso seja 0 o dado pode ser salvo
diretamente.

Ainda existe uma variação chamada Transparent SME, onde tudo é criptografado.
Nesse caso não é necessário suporte do SO, tendo em vista que não é preciso
fazer o controle de quais endereços serã criptografados e quais não. O processo
de acesso à memória ocorre da mesma forma que em SME\@.


\section{Secure Encrypted Virtualization}
Secure Encrypted Virtualization (SEV) integra o SME com a capacidade de
comportar várias VMs criptografadas. Durante o boot a máquina host recebe uma
chave, a qual é utilizada da mesma maneira que em SEV. O diferencial do SEV é
que após a inicialização cada máquina virtual também ganha uma chave única,
podendo assim criptografar seus dados e protegê-los tanto do hypervisor como de
outros guests sendo executados no host.

\begin{figure}[h]
    \centering
    \includegraphics[width=0.5\textwidth]{img/sev}
    \label{sev}
\end{figure}

A figura~\ref{sev}, apesar de muito similar a ~\ref{sme}, mostra como o
acesso à memória se dá com a utilização sempre da chave correspondente à
máquina que realizou a operação.


\begin{figure}[h]
    \centering
    \includegraphics[width=1\textwidth]{img/sev-architecture}
    \label{sev-architecture}
\end{figure}

~\ref{sev-architecture} é uma visão geral da arquitetura do SEV, nela é possível encontrar:

\begin{description}
    \item[Guest Owner]: Usuário que contratou o serviço e interage com sua VM.
    \item[Hypervisor]: Interage com as VMs e com o Secure Processor através de
    drivers.
    \item[VM]: Virtual Machine sendo executada no host.
    \item[Secure Processor]: Tem acesso exclusivo ao banco de chaves e interage
    com o SPI flash.
    \item[SPI Flash]: Utilizado para o gerenciamento de chaves.
    \item[Memory Controller]: Controla os acessos à memória aplicando
    conceitos visto acima, como por exemplo a criptografia.
    \item[DRAM]: Memória que armazena os dados dos guests e do host.
\end{description}

\begin{figure}[h]
    \centering
    \includegraphics[width=0.5\textwidth]{img/asid}
    \label{asid}
\end{figure}

Para implementar essa tecnologia também é usado o Address Space ID (ASID), que
é usado para identificar a chave que pertence à VM. Para tirar proveito disso, o identificador
também é utilizado para definir de quem é um dado na cache, escritas à cache
concatenam o identificador ao dado inserido. Após uma tentativa de acessar o dado, após ser encontrado
encontrado pela TLB, é feita uma verificação para garantir que os
identificadores são correspondentes antes de garantir um cache hit. Isso faz
com que não seja necessário esvaziar a TLB em caso de troca de contexto entre
VMs, uma vez que o identificador da chave causará um miss, aumentando
o desempenho. Esse comportamento é mostrado em ~\ref{asid}.

\begin{figure}[h]
    \centering
    \includegraphics[width=1\textwidth]{img/sev-address-translation}
    \label{sev-address-translation}
\end{figure}

Um exemplo da tradução de endereço é visto em ~\ref{sev-address-translation}.
Primeiramente o guest traduz o endereço para o que ele acredita ser o endereço
físico. Após isso o host calcula o real endereço físico requisitado, deixando
de lado o C-bit. Uma vez que o endereço físico é encontrado, o C-bit é
novamente inserido e o dado pode ser consultado na cache.

Além disso, é possível existir conflito ao decidir se uma página é criptografada
ou não. Uma página do guest pode ter o C-bit marcado como 0, mas sua página
física correspondente no host ter C-bit 1. Nesses caso a página seria
criptografada com a chave do host, porém caso os dois C-bits sejam 1 o guest
teria prioridade, logo a chave usada seria a sua.

Um SVE poderia garantir proteção contra o exploit visto em 1.3.1. Uma
tentativa de analisar o checksum com páginas criptografadas seria um desafio
muito maior, além de que uma escrita na RAM, ao ser descriptografada pelo host,
não faria muito sentido, já que foi criptografada por uma VM ou simplesmente
não teve criptografia. Caso a VM ainda assim conseguisse controle do host,
outras VMs estariam protegidas por utilizar sua própria chave.

\section{Aplicação do SME e SEV}

\section{}

\bibliographystyle{ieeetr}
\nocite{*}
\bibliography{references}

\end{document}
